Ext.define('Ayushman.controller.cdm.components.SingleInstructionContainerController', { extend : 'Ayushman.common.baseclasses.controller.BaseController',   requires: ['Ext.util.HashMap','Ext.util.DelayedTask'],    config: 	{		// as the corresponding view class for this controller is not in the default namespace, we must set the nameSpacePrefix property		nameSpacePrefix: 'Ayushman.view.cdm.components.',		instructionType: null,		planId: null,		instructionNumber: null,		isContentSaved: false,		//this reference is used to remove the object from objectsToSave of InstructionHolder,		//when the instruction corresponding to this controller instance is deleted using the 'delete' button from ui.		instrHoldersObjectsToSave: null,		//this key is used to remove the object from objectsToSave of InstructionHolder,		//when this instruction is deleted using the 'delete' button from ui.		keyInInstrHoldersObjectsToSave: null,		initializationConfiguration: null	},	 	createInstanceOfView: function()	{		this.callParent();						},	 	tap_deleteSingleInstructionButton: function()	{		console.log(" Delete is getting called! ");		this.getInstrHoldersObjectsToSave().removeAtKey(this.getKeyInInstrHoldersObjectsToSave());		this.getViewInstance().destroy();	},		save: function()	{							var store = Ext.getStore('SingleInstructionContainerStore');			/* Following handling is required because store's asynchronous behaviour.			   As this function is getting called for each object to be saved in InstructionHolder, and as the same store is being used..			   So we have to wait until the store is loaded if it is loading */			if(store.isLoading() === true)			{					 var task = Ext.create('Ext.util.DelayedTask', function() {												this.save();					}, this);					task.delay(100);			}			else			{				/* now eventhogh store is loaded, but some other object from objectsToSave of InstructionHolder has added some records which are not yet written to the 				 server, so we have to wait, until the store finishes with its pending task. */				if( store.getNewRecords().length > 0)				{					var task = Ext.create('Ext.util.DelayedTask', function() {						console.log('hi2');						this.save();					}, this);					task.delay(100);				}				else				{					//now store has no phantom/dirty records, so we can use the store now					store.load(function() {							var instructionTypesStore = Ext.getStore('InstructionTypes');							instructionTypesStore.clearFilter();							var instrTypeDetails = instructionTypesStore.findRecord('instruction_type_value',this.getInstructionType());							store.add({ 									plan_id : this.getPlanId(),									instruction_type_id  : instrTypeDetails.get('id'),									instruction_number : this.getInstructionNumber()								});															store.sync();						}, this);																		var generatedInstrId = null;							store.on('write', function(storeRef, operation, eOpts)						{							if(operation.getAction() === 'create')							{								var recordsArray = operation.getRecords();								generatedInstrId = recordsArray[0].getData().id;								console.log("The generated Id at the server side is :" + generatedInstrId);								if(this.getIsContentSaved() === false)								{									this.saveInstructionParameters(generatedInstrId);								}							}													}, this);				}			}					console.log("SingleInstructionContainerControllers save function is called!");			},		saveInstructionParameters: function(generatedInstrId)	{		this.setIsContentSaved(true);		console.log("Inside the saveInstructionParameters function and the generated id is :" + generatedInstrId);				var instructionParametersStore = Ext.getStore('InstructionParametersStore');		instructionParametersStore.load(function() 		{								var instructionAtrrArray = this.getViewInstance().getInnerItems()[0].getInnerItems();				Ext.Array.forEach(instructionAtrrArray, function(itemInnerLoop, indexInner, instructionAtrrArray)				{							if( itemInnerLoop.getInnerItems()[0].config.instructionAttr == 'food_based_nutrition_options')							{								var foodItemsOptionsContainerArray = itemInnerLoop.getInnerItems()[1].getInnerItems();								var selectedFoodItemsArray = [];								Ext.Array.forEach(foodItemsOptionsContainerArray, function(itemFoodOptionsContainer, indexInner, foodItemsOptionsContainerArray)								{									var foodOptionsArray = itemFoodOptionsContainer.getInnerItems();									Ext.Array.forEach(foodOptionsArray, function(itemFoodOption, indexInner, foodOptionsArray)									{										// if the item is of 'checkboxfield' then only push the value of that checkbox into array if that checkbox is checked										if(itemFoodOption.isXType('checkboxfield') == true)										{											if(itemFoodOption.isChecked() == true)											{												selectedFoodItemsArray.push(itemFoodOption.getValue());											}										}									});								});																instructionParametersStore.add(																{ 																		plan_instruction_id : generatedInstrId,																	instruction_attribute :	itemInnerLoop.getInnerItems()[0].config.instructionAttr,																	instruction_attribute_value : 	selectedFoodItemsArray.toString()																}															);															}							else							{																instructionParametersStore.add(																{ 																		plan_instruction_id : generatedInstrId,																	instruction_attribute :	itemInnerLoop.getInnerItems()[0].config.instructionAttr,																	instruction_attribute_value : 	itemInnerLoop.getInnerItems()[1].getValue()																}															);															}				});						instructionParametersStore.sync();								}, this);				},		saveEditedInstructionToStore: function()	{		var instructionParametersStore = Ext.getStore('InstructionParametersStore');		instructionParametersStore.clearFilter();					var initialConfig = this.getInitializationConfiguration();			var planInstructionId = initialConfig["instruction_id"];			instructionParametersStore.filter([{property: "plan_instruction_id", value: planInstructionId}]);			var countOfRecords = instructionParametersStore.getCount();			//				var instructionDetailsArray = {};				var instructionAtrrArray = this.getViewInstance().getInnerItems()[0].getInnerItems();				Ext.Array.forEach(instructionAtrrArray, function(itemInnerLoop, indexInner, instructionAtrrArray)				{							if( itemInnerLoop.getInnerItems()[0].config.instructionAttr == 'food_based_nutrition_options')							{								var foodItemsOptionsContainerArray = itemInnerLoop.getInnerItems()[1].getInnerItems();								var selectedFoodItemsArray = [];								Ext.Array.forEach(foodItemsOptionsContainerArray, function(itemFoodOptionsContainer, indexInner, foodItemsOptionsContainerArray)								{									var foodOptionsArray = itemFoodOptionsContainer.getInnerItems();									Ext.Array.forEach(foodOptionsArray, function(itemFoodOption, indexInner, foodOptionsArray)									{										// if the item is of 'checkboxfield' then only push the value of that checkbox into array if that checkbox is checked										if(itemFoodOption.isXType('checkboxfield') == true)										{											if(itemFoodOption.isChecked() == true)											{												selectedFoodItemsArray.push(itemFoodOption.getValue());											}										}									});								});																	instructionDetailsArray[itemInnerLoop.getInnerItems()[0].config.instructionAttr] = selectedFoodItemsArray.toString();							}							else							{								instructionDetailsArray[itemInnerLoop.getInnerItems()[0].config.instructionAttr] = itemInnerLoop.getInnerItems()[1].getValue();							}				});			//			console.log(instructionDetailsArray);			instructionParametersStore.each(function (record, index, length) {				var instructionAttribute = record.get('instruction_attribute');				record.set('instruction_attribute_value', instructionDetailsArray[instructionAttribute]);			}, this);						console.log("Hello.. this is inside the SingleInstructionContainerController! " +initialConfig["instruction_id"]);				},		destroy: function()	{		console.log("Destroy of  SingleInstructionContainerController has been called!");		this.callParent();		// TODO : abstract the following code, for setting the variables to null, into base class.		this.setNameSpacePrefix(null);		this.setInstructionType(null);		this.setInstrHoldersObjectsToSave(null);		this.setKeyInInstrHoldersObjectsToSave(null);		console.log("Destroy of SingleInstructionContainerController has been Finished!");	}});